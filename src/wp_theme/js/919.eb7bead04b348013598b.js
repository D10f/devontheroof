(self.webpackChunkwebpack_v5_dom_typescript=self.webpackChunkwebpack_v5_dom_typescript||[]).push([[919],{919:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return q}});var r=t(212),o=t(358),a=document.querySelector("#earth"),i=a.clientWidth,s=a.clientHeight,d=new r.xsS,v=new r.cPb(75,i/s,.1,1e3);v.position.set(0,0,10);var l=new r.ZAu,c=new r.CP7({antialias:!0});c.setSize(i,s),c.setPixelRatio(window.devicePixelRatio);var u={x:void 0,y:void 0};a.addEventListener("mousemove",(function(e){u.x=e.clientX/i*2-1,u.y=e.clientY/s*2+1}));for(var m=new r.u9r,x=new r.UY4({color:16777215}),h=[],p=0;p<1e4;p++){var w=2e3*(Math.random()-.5),y=2e3*(Math.random()-.5),f=-1*(2e3*Math.random()+100);h.push(w,y,f)}m.setAttribute("position",new r.a$l(h,3));var g=new r.woe(m,x),b=t(373),M=t(401),j=t.n(M),_=t(561),N=t.n(_),S=t(178),P=t.n(S),V=t(153),C=t.n(V),U=new r.xo$(5,50,50),k=(new r.vBJ({map:(new r.dpR).load(b)}),new r.jyz({vertexShader:j(),fragmentShader:N(),uniforms:{globeTexture:{value:(new r.dpR).load(b)}}})),z=new r.jyz({vertexShader:P(),fragmentShader:C(),blending:r.WMw,side:r._Li}),F=new r.Kj0(U,k),T=new r.Kj0(U,z);T.scale.set(1.1,1.1,1.1);var A=new r.SUY,L=1/60,R=0,W=0;l.add(F),l.add(T),d.add(g),d.add(l),F.rotation.y=-1.75,T.rotation.y=-1.75,F.rotation.x=.4,T.rotation.x=.4;var q={animate:function e(){return n=(R+=A.getDelta())<=L,R%=L,n?requestAnimationFrame(e):(W=requestAnimationFrame(e),a.appendChild(c.domElement),c.render(d,v),u.x>=0?(F.rotation.y+=.005,T.rotation.y+=.005):(F.rotation.y-=.005,T.rotation.y-=.005),o.ZP.to(l.rotation,{x:.075*u.y,y:.1*u.x,duration:4}),W);var n},destroy:function(){c.dispose(),c.clear(),cancelAnimationFrame(W)}}},153:function(e){e.exports="varying vec3 vertexNormal; // (0, 0, 0)\n\nvoid main() {\n  float intensity = pow(0.75 - dot(vertexNormal, vec3(0, 0, 1.0)), 2.0);\n  gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;\n}\n"},178:function(e){e.exports="varying vec3 vertexNormal;\n\nvoid main() {\n  vertexNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"},561:function(e){e.exports="\n// This is the uniform we provided when declaring the ShaderMaterial in .js\nuniform sampler2D globeTexture;\n\n// We declared this in the vertex shader which always runs first, before the\n// fragment shader. Now we can use it in this file\nvarying vec2 vertexUV;\nvarying vec3 vertexNormal;\n\nvoid main() {\n  // this function comes built-in with GLSL\n  // texture2D(globeTexture, vertexUV);\n\n  // Pixel color (r,g,b,a values)\n  // gl_FragColor = vec4(1, 0, 0, 1);\n\n  // formula to generate a shader of blue around the edges\n  float intensity = 1.05 - dot(vertexNormal, vec3(0.0, 0.0, 1.0));\n  vec3 atmosphere = vec3(0.3, 0.6, 1.0) * pow(intensity, 1.5);\n\n  gl_FragColor = vec4(atmosphere + texture2D(globeTexture, vertexUV).xyz, 1.0);\n}\n"},401:function(e){e.exports="// https://threejs.org/docs/index.html?q=web#api/en/renderers/webgl/WebGLProgram\n\n// Runs for every vertex and adjust the position coordinates.\n\n// default vertex attributes provided by Geometry and BufferGeometry\n// attribute vec3 position;\n// attribute vec3 normal;\n// attribute vec2 uv;\n\n// Note that you can therefore calculate the position of a vertex in the vertex shader by:\n// projectionMatrix and modelViewMatrix are provided by Three.js\n\n// We use a varying to pass this value to another shader\nvarying vec2 vertexUV;\nvarying vec3 vertexNormal;\n\nvoid main() {\n  vertexUV = uv;\n  vertexNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"},373:function(e,n,t){"use strict";e.exports=t.p+"images/earth.jpg"}}]);